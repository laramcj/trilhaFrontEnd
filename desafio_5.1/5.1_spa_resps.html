<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
</head>

<body>
    <h1>Desafio 5.1</h1>
    <h2>Respostas:</h2>
    <p>
        <strong>a)</strong>
        MPA – Multiple Page Application é o modelo
        convencional de construção de software front-end. Sempre que abrimos uma
        página na internet, as informações apresentadas na tela são carregadas de
        algum lugar, seja uma imagem, um vídeo, ou um json. Tudo vem de algum
        lugar, tudo chega ao usuário através de uma request.<br />
        SPA - Single Page Application, neste modelo o browser vai renderizar o
        core da aplicação apenas uma vez – todas as outras informações serão
        carregadas por demanda, de acordo com a necessidade do usuário. Além de
        gerar menos custos para renderizar a página, o modelo SPA ainda oferece
        uma melhor experiência para o usuário, pois o mesmo não terá que ver a
        página recarregando completamente inúmeras vezes.
    </p>
    <p>
        <strong>b)</strong>
        Anos 90 - A proposta da World Wide Web foi feita
        originalmente em 1989, mas foi no ano seguinte que ela começa a tomar
        forma, com a ajuda de Robert Cailliau. Foi ele quem reformulou e
        formalizou o sistema, despertando o interesse de universidades que
        utilizavam outros formatos de rede. Mas não foi só a proposta do WWW que
        permitiu seu sucesso. Tim Berners-Lee passou cerca de dois anos
        desenvolvendo também algumas das bases desse sistema de navegação por
        cliques, que são duas siglas bastante conhecidas na área: o HTTP e o HTML.
        <br />
        Com as invenções de Berners-Lee e várias evoluções e melhorias nesses
        protocolos e códigos, finalmente chegamos à internet como a conhecemos.
        Seu avanço foi tão importante que, atualmente, web é praticamente um
        sinônimo para a internet em geral. <br />
        Os primeiros navegadores de que se têm notícia chamavam-se Erwise e
        ViolaWWW. Em abril de 1992, esses dois programas desenvolvidos na Alemanha
        e nos Estados Unidos, respectivamente, começaram a navegação pela web com
        uma interface ainda tímida graficamente. A Google foi fundada por Larry
        Page e Sergey Brin de forma modesta e apenas em 1998. Diferente da maioria
        dos concorrentes, que apresentava dados dispersos, o novo buscador
        realizava maior filtragem e impunha uma hierarquização nos resultados, de
        acordo com a relevância e a proximidade com as palavras pesquisadas.
        <br />
        Anos 2000 - A moda tradicional da época era usar cores fortes e poucas
        imagens. Quem criava sites fazia com que eles fossem simples, sem imagens,
        gifs ou vídeos, para não pesar a página e fazer com que o carregamento não
        demorasse muito na internet discada. A publicidade era, portanto, simples
        e direta e o acesso à informação estava concentrado em um pequeno grupo de
        portais. As pessoas geralmente tinham a sua conta de e-mail, um portal de
        notícias favorito e um site de humor para se entreter. Assim, a indicação
        direta de um site para outro era eficiente para aumentar o alcance de
        ambos.
    </p>
    <p>
        <strong>c)</strong>
        As principais diferenças entre esses formatos de WEB
        estão na dinâmica e interatividade. Um site com o formato de WEB 1.0 é
        estático e sem nenhuma forma de interatividade com os leitores. É possível
        visitá-lo muitas vezes, mas não haverá nada de novo em todas as novas
        visitas e não há motivo para retornar a ele. Com o tempo, a maior parte
        dos sites migrou do formato 1.0 para o formato 2.0, que consiste em uma
        maior interação dentro de cada página. A partir desse novo formato de WEB,
        foi possível a criação de blogs e da Wikipédia, em que o leitor não é
        passivo em relação ao que está publicado. WEB 2.0 não se refere a um
        avanço específico na tecnologia, mas a um conjunto de técnicas para design
        e execução de páginas da Web. Além disso, algumas dessas técnicas existem
        desde que a World Wide Web (www) foi lançada, de modo que não é possível
        separar Web 1.0 e a Web 2.0 em termos cronológicos. A definição de Web 1.0
        é dependente da definição de Web 2.0. A WEB 3.0 consiste em algo além da
        interatividade. Páginas nesse formato personalizam o conteúdo de maior
        relevância de acordo com as preferências de cada pessoa. Por exemplo, ao
        usar a ferramenta do Google para procurar a palavra “Manga”, nos outros
        formatos, o buscador mostraria resultados tanto da fruta, quanto de uma
        camisa, quanto do ex-jogador de futebol. Caso um jornalista esportivo
        estivesse buscando informações sobre o jogador para uma matéria de
        futebol, seria pouco relevante para ele, enquanto na WEB 3.0, o buscador
        reconheceria as preferências do usuário e filtraria os resultados de
        pesquisa para uma maior relevância de resultados.
    </p>
    <p>
        <strong>d)</strong>
        <ul>
            <li>
                I. Angular é uma plataforma e framework para construção
                da interface de aplicações usando HTML, CSS e, principalmente, JavaScript,
                criada pelos desenvolvedores da Google. Ele possui alguns elementos
                básicos que tornam essa construção interessante. Dentre os principais,
                podemos destacar os componentes, templates, diretivas, roteamento,
                módulos, serviços, injeção de dependências e ferramentas de infraestrutura
                que automatizam tarefas, como a de executar os testes unitários de uma
                aplicação. Angular nos ajuda a criar Single-Page Applications com uma
                qualidade e produtividade surpeendente! Alguns outros pontos dessa
                plataforma que merecem destaque são o fato de que ela é open source,
                possui uma grande comunidade, existem várias empresas utilizando e tem
                muito material de estudo para quem deseja se aperfeiçoar.
            </li>
            <li>
                II. Angular é um framework JavaScript de código aberto mantido pela Google
                para a construção de SPA (sigla para Single Page Applications ou Aplicações
                de Página Única).
            </li>
            <li>
                III. Em uma aplicação básica é essencial ter: Components, Templates, Dependency injection.
            </li>
            <li>
                IV. O Angular CLI é uma ferramenta open source desenvolvida pelo próprio time
                do Angular e é utilizado para facilitar a criação de componentes, classes,
                services e outros. É uma interface de linha de comando (command line interface)
                para facilitar e acelerar a criação de nossas aplicações. Quando a versão 1.0
                final do CLI foi lançada, ele se tornou a forma oficial para iniciar um novo
                projeto em Angular. O Angular CLI é baseado no Webpack, uma ferramenta que ajuda
                a processar e agrupar nossos diversos arquivos TypeScript, JavaScript, CSS, HTML
                e imagens. Por baixo dos panos, o Webpack é responsável por estruturar o ponto de
                entrada da aplicação, ou seja, a raiz contextual (arquivo de inicialização). <br>
                Dentre algumas facilidades disponibilizadas pela ferramenta, podemos destacar a
                criação de um novo projeto Angular: toda a estrutura inicial do projeto pode ser
                construída com um simples comando ng new NOME-DO-PROJETO.
            </li>
            <li>
                V. O arquivo angular.json contém as configurações globais da aplicação, também
                define o arquivo que vai iniciar a aplicação, fazendo o SPA.
            </li>
            <li>
                VI. "dependencies": {
                    "@angular/animations": "~7.0.0",
                    "@angular/common": "~7.0.0",
                    "@angular/compiler": "~7.0.0",
                    "@angular/core": "~7.0.0",
                    "@angular/forms": "~7.0.0",
                    "@angular/http": "~7.0.0",
                    "@angular/platform-browser": "~7.0.0",
                    "@angular/platform-browser-dynamic": "~7.0.0",
                    "@angular/router": "~7.0.0",
                    "core-js": "^2.5.4",
                    "rxjs": "~6.3.3",
                    "zone.js": "~0.8.26"
                  },
                Depois de criar o projeto Angular, navegar até o arquivo package.json. Lá dentro, encontrar o
                "Dependencies": { }. O conteúdo do dependencies são as dependencies padrão (default)
            </li>
            <li>
                VII. Package.json: Contém todas as dependências da aplicação, à medida que instalar
                uma nova dependência, ela vai aparecer no arquivo.
            </li>
            <li>
                VIII. O arquivo environment.ts contém as configurações de ambiente padrão.
            </li>
        </ul>
    </p>
    <p>
        <strong>e)</strong>
        <ul>
            <li>
                I. Text interpolation permite incorporar valores de string dinâmicos em seus modelos
                HTML. Ela é usada para alterar dinamicamente o que aparece em uma visualização
                do aplicativo, como a exibição de uma saudação personalizada que inclui o nome do usuário.
            </li>
            <li>
                II. Com a interpolação, o Angular executa as seguintes tarefas: <br>
                - Avalia todas as expressões entre chaves duplas. <br>
                - Converte os resultados da expressão em strings. <br>
                - Vincula os resultados a quaisquer strings literais adjacentes. <br>
                - Atribui o composto a um elemento ou propriedade de diretiva. <br>
            </li>
            <li>
                III.
                "@Component({
                template:
                <div>
                    <p> Meu nome é: {{nome}} e do meu guia é: {{guia}}</p>
                    <p> Data de hoje: {{dataDesafio}}</p>
                    <p> Faço parte da turma: {{numeroTurma}}</p>
                </div>
                })
                class AppComponent {
                nome = 'Lara Maia Corrêa Joaquim';
                guia = 'Elivel Santos Nascimento';
                dataDesafio = 'Quinta 15 de dezembro de 2021 14:31:05 GMT-0300';
                numeroTurma = 'Turma Cybertron - Só Vamu!'
                }
                "
            </li>
        </ul>
    </p>
    <p>
        <strong>f)</strong>
        <ul>
            <li>
                I. Property binding no Angular ajuda a definir valores para propriedades de elementos ou diretivas HTML.
                Ela é usada para fazer coisas como a funcionalidade do botão de alternância(toggle button), definir
                caminhos programaticamente e compartilhar valores entre os componentes.
            </li>
            <li>
                II. O Property Binding move um valor em uma direção, da propriedade de um componente para uma
                propriedade do elemento de destino.
            </li>
            <li>
                III. <img [src]="itemImageUrl">
                Para fazer um binding é necessário envolver a propriedade em [] para que o angular consiga encontrar.

                O itemImageUrl precisa ser declarado em uma classe:

                itemImageUrl = '../assets/phone.png';

            </li>
            <li>
                IV. Event Binding permite criar um listener para "escutar" eventos (ações) do usuário na tela, como
                cliques, toque, movimentos de mouse e uso de teclas.
            </li>
            <li>
                V. <button (click)="onSave()">Save</button>

                Nesse caso, o evento a ser escutado será o click, que precisa ser escrito dentro do () e o método a ser
                chamado quando o evento ocorrer é o "onSave()".
            </li>
            <li>
                VI. Two-way binding é uma forma dos componentes da aplicação compartilhar dados.
                Usamos Two-way binding para ouvir eventos e atualizar valores simultaneamente entre os componentes pai e
                filho.
            </li>
            <li>
                VII. <app-sizer [(size)]="fontSizePx"></app-sizer>

                Usamos a combinação de [()] para indicar um target.

                Na aplicação utilizamos o @Input() e @Output(). O padrão de nomenclatura a seguir é:

                Se a o a proriedade (input) é o size, o evento (output) deve se chamar sizeChange.

                Os dados seguem o fluxo entrando pelo input (size) no Component, o evento output (sizeChange) faz com
                que o fluxo saia
                e vá para o componente pai. Para emitir os dados para a outra camada, utilizamos o método emit dessa
                forma: sizeChange.emit(newSize)
            </li>
        </ul>
    </p>

    <p>
        <strong>g)</strong>
        <ul>
            <li>
                I. As diretivas são classes que adicionam comportamento adicional aos elementos em seus aplicativos
                Angular.
                Utilizamos as diretivas integradas do Angular para gerenciar formulários, listas, estilos e o que os
                usuários veem.
            </li>
            <li>
                II. Existem 3 tipos de diretivas, são elas:

                - Components: São diretivas com templates, é o tipo de diretiva mais comum;
                - Attribute directive: São diretivas que alteram a aparencia ou comportamento de um elemento, componente
                ou outra diretiva;
                - Structural directive: São diretivas que alteram o layout, adicionamento ou removendo elementos.
            </li>
            <li>
                III.
                - NgClass: Adiciona ou remove classes CSS. Exemplo:

                <div [ngClass]="isSpecial ? 'special' : ''">This div is special</div>

                ou

                <div [ngClass]="currentClasses">This div is special.</div>

                Podemos escrever diretamente ou utilizar binding para atribuir um método.

                - NgStyle: Adiciona ou remove estilos inline no HTML. Exemplo:

                <div [ngStyle]="currentStyles">
                    This div is initially italic, normal weight, and extra large (24px).
                </div>

                Onde current styles é um atributo no componente:

                currentStyles: Record<string, string> = {};
                    setCurrentStyles() {
                    this.currentStyles = {
                    'font-style': this.canSave ? 'italic' : 'normal',
                    'font-weight': !this.isUnchanged ? 'bold' : 'normal',
                    'font-size': this.isSpecial ? '24px' : '12px'
                    };
                    }

                    - NgModel: Adiciona data binding em um elemento HTML. Exemplo:

                    <label for="example-ngModel">[(ngModel)]:</label>
                    <input [(ngModel)]="currentItem.name" id="example-ngModel">

                    - NgIf: É uma condição que cria ou remove uma subview do template. Exemplo:

                    <app-item-detail *ngIf="isActive" [item]="item"></app-item-detail>

                    Se for falso, os elementos e seus filhos são removidos do DOM.
                    O angular removerá seus componentes o que acaba liberando memória e recursos

                    Ainda é possível utilizar o NgIfElse para adicionar comportamentos ou exibir outro elemento.

                    O NgIf também é importante para previnir a exibição de elementos com valor null.

                    - NgFor: Repetição de um nó pra cada item de uma lista. Exemplo:

                    <div *ngFor="let item of items">{{item.name}}</div>

                    - NgSwitch: É um conjunto de regras para alternar entre views. Exemplo:

                    <div [ngSwitch]="currentItem.feature">
                        <app-stout-item *ngSwitchCase="'stout'" [item]="currentItem"></app-stout-item>
                        <app-device-item *ngSwitchCase="'slim'" [item]="currentItem"></app-device-item>
                        <app-lost-item *ngSwitchCase="'vintage'" [item]="currentItem"></app-lost-item>
                        <app-best-item *ngSwitchCase="'bright'" [item]="currentItem"></app-best-item>
                        <app-unknown-item *ngSwitchDefault [item]="currentItem"></app-unknown-item>
                    </div>
            </li>
        </ul>
    </p>
    <p>
        <strong>h)</strong>
        <ul>
            <li>
                I. Template-driven forms usa o FormsModule, é assincrono e a maior parte da lógica está no template.
                Já o Reactive Forms usa o "ReactiveFormsModule", é sincrono e a maior parte da lógica está no componente.
            </li>
            <li>
                II. O Reactive Form nos permite remover a maior parte da lógica do template, tornando o código mais isolado e limpo. 
                Com isso passamos ter maior facilidade na escrita de çodigos unitários.
            </li>
            <li>
                III. ReactiveFormsComponent e FormsModule
            </li>
            <li>
                IV. AbstractControl é a abstract class base para as 3 form control class:
                FormControl, FormGroup, and FormArray. 

                FormControl localiza o valor e o status de validade de um controle de formulário individual. Corresponde a um controle de formulário HTML, como uma caixa de entrada ou seletor
                
                FormGroup localiza o valor e o estado de validade de um grupo de instâncias AbstractControl. As propriedades do grupo incluem seus controles filhos. O formulário de nível superior em seu componente é um FormGroup.
                
                FormArray localiza o valor e o estado de validade de uma matriz numericamente indexada de instâncias AbstractControl.
            </li>
            <li>
                V. 
                    - FormControl: 
                        1. Registre o module de reactive forms em sua aplicação. Este module declara as directives de forma reativa de que você precisa para usar as reactive forms.
                        2. Gere uma nova instância de FormControl e salve-a no componente.
                        3. Registre o FormControl no modelo.
                    
                    - FormGroup:
                        1. Criar uma instância de FormGroup.
                        2. Associar o FormGroup a um model e uma view.
                        3. Salvar os dados do formulário.

                    - FormArray:
                        1. Importar a classe FormArray.
                        2. Definir um FormArray control.
                        3. Acessar o FormArray control com um método getter.
                        4. Exibir o form array no template.      
            </li>
            <li>
                VI. Quando os dados são atualizados na view:

                        1. O usuário entra com um dado;
                        2. O form emite um input event com o valor;
                        3. O valor é passado para a instância do FormControl;
                        4. O FormControl emite um novo valor utilizando o valueChanges;
                        5. Quem estiver observando o valueChanges recebe o novo valor;

                    Quando os dados vem do model para a view:

                        1. O método setValue() é chamado, que atualiza o valor no FormControl;
                        2. A instância do FormControl emite um novo value usando o valueChanges;
                        3. Quem estiver observando o valueChanges recebe o novo valor;
                        4. O elemento na view  é atualizado com o novo valor;
            </li>
            <li>
                VII. O FormControl emite novos valores através do valueChanges. Os subscribers do valueChanges observam mudanças e atualizam a view.
            </li>
            <li>
                VIII. É importante validar o formulário para recebermos dados de qualidades e completos. 
                Também, através da valição, podemos fornecer feedbacks na view para informar o usuário de possíveis erros no preenchimento.

                Em Reactive Forms adicionamos métodos de validação no form control nome na classe do componente. Temos dois tipos de validadores:
                    - Sync validatores: funções sincronas que retornam um conjunto de erros de validação ou null imediatamente.
                    - Async validatores: funções assincronas que retornam uma Promise ou Observable que retornarão um conjunto de erros de validação ou null.

                Para apresentar os erros de form para o usuário, podemos seguir dessa forma:

                <input type="text" id="name" class="form-control"
                    formControlName="name" required>

                <div *ngIf="name.invalid && (name.dirty || name.touched)"
                    class="alert alert-danger">

                    <div *ngIf="name.errors?.['required']">
                        Name is required.
                    </div>
                    <div *ngIf="name.errors?.['minlength']">
                        Name must be at least 4 characters long.
                    </div>
                    <div *ngIf="name.errors?.['forbiddenName']">
                        Name cannot be Bob.
                    </div>
                </div>

                Dessa forma utilizamos o name getter que foi definido no componente.
            </li>
        </ul>
    </p>


</body>

</html>